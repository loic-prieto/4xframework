package org.sephire.games.framework4x.core.plugins;

import io.vavr.API;
import io.vavr.Tuple;
import io.vavr.Tuple3;
import io.vavr.collection.List;
import io.vavr.collection.Map;
import io.vavr.collection.Set;
import io.vavr.collection.*;
import io.vavr.control.Option;
import io.vavr.control.Try;
import lombok.Getter;
import org.reflections.Reflections;
import org.reflections.scanners.ResourcesScanner;
import org.sephire.games.framework4x.core.model.config.Configuration;
import org.sephire.games.framework4x.core.model.config.CoreConfigKeyEnum;
import org.sephire.games.framework4x.core.plugins.configuration.*;
import org.sephire.games.framework4x.core.plugins.map.MapGeneratorWrapper;
import org.sephire.games.framework4x.core.plugins.map.MapProvider;
import org.sephire.games.framework4x.core.plugins.map.MapProviderWrapper;
import org.sephire.games.framework4x.core.plugins.map.MapProviderWrappingException;

import javax.naming.OperationNotSupportedException;
import java.util.Locale;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.regex.Pattern;

import static io.vavr.API.*;
import static io.vavr.Predicates.instanceOf;
import static java.lang.String.format;
import static org.sephire.games.framework4x.core.model.config.CoreConfigKeyEnum.I18N;
import static org.sephire.games.framework4x.core.model.config.CoreConfigKeyEnum.TERRAIN_TYPES;
import static org.sephire.games.framework4x.core.utils.ResourceLoading.normalizePackageNameForReflection;
import static org.sephire.games.framework4x.core.utils.ResourceLoading.packageToFolderPath;

/**
 * <p>Represents a plugin to be loaded when a game starts.</p>
 * <p>A plugin may define model entities as declared in the core framework, if it is a base plugin, or may
 * override and extend the configuration of a base plugin.</p>
 */
public class Plugin {

	@Getter
	private PluginSpec specification;

	private Plugin(PluginSpec spec) {
		this.specification = spec;
	}

	/**
	 * Given a plugin spec, it will try to load it from the classpath.
	 * A plugin has a root package, from which it will scan all automatic
	 * resources and the configuration classes and initialize all those
	 * resources.
	 *
	 * May return the following exceptions as errors:
	 *  - InvalidPluginLifecycleHandlerException
	 *  - PluginLoadingException
	 *
	 * @param pluginSpec
	 * @return
	 */
	public static Try<Plugin> from(PluginSpec pluginSpec,Configuration.Builder configuration) {
		return Try.of(()->{
			var plugin = new Plugin(pluginSpec);
			var loadingTry = plugin.load(configuration);
			if(loadingTry.isFailure()) {
				throw loadingTry.getCause();
			}

			return plugin;
		});
	}

	private static void updateConfigWithBundleEntry(Configuration.Builder configuration, Tuple3<Locale, String, String> bundleEntry) {
		var i18nMap = configuration.getConfig(CoreConfigKeyEnum.I18N).map((v) -> (Map<Locale, Map<String, String>>) v)
		  .getOrElse(HashMap.empty());
		var i18nLocaleMap = i18nMap.get(bundleEntry._1).getOrElse(HashMap.empty());
		configuration.putConfig(
		  I18N,
		  i18nMap.put(
			bundleEntry._1,
			i18nLocaleMap.put(
			  bundleEntry._2, bundleEntry._3)));
	}

	private static Option<ResourceBundle> bundleFromFileName(String filename) {
		var bundleInfo = filename.split("_");
		if (bundleInfo.length < 2 || bundleInfo.length > 3) {
			return Option.none();
		} else {
			if (bundleInfo.length == 2) {
				return Option.of(PropertyResourceBundle.getBundle(
				  bundleInfo[0],
				  Locale.forLanguageTag(
					bundleInfo[1])));
			} else {
				return Option.of(
				  PropertyResourceBundle.getBundle(
					bundleInfo[0],
					Locale.forLanguageTag(
					  bundleInfo[1]
						.concat("-")
						.concat(bundleInfo[2]))));
			}
		}
	}

	private static Set<Tuple3<Locale, String, String>> entriesFromBundle(ResourceBundle bundle) {
		return HashSet.ofAll(bundle.keySet())
		  .map((key) -> Tuple.of(bundle.getLocale(), key, bundle.getString(key)));
	}

	/**
	 * <p>Will invoke the initializing of the plugin resources and configuration with a given
	 * external configuration ready to be filled.</p>
	 * <p>The result of this process tells if it was successful, so that dependent plugins are not
	 * loaded</p>
	 * <p>The configuration object will be updated in place</p>
	 *
	 * @param configuration
	 */
	private Try<Void> load(Configuration.Builder configuration) {

		return loadTerrainResources(configuration)
		  .andThen(() -> loadMapGenerators(configuration))
		  .andThen(() -> loadI18NResources(configuration))
		  .andThen(() -> callPluginLoadingHooks(configuration));
	}

	/**
	 * Allows a plugin to hook into the plugin loading process, which allows to put some extra configuration
	 * that cannot be generated by the standard resource files or generators.
	 * @param configuration
	 * @return
	 */
	private Try<Void> callPluginLoadingHooks(Configuration.Builder configuration) {
		return Try.of(()->{
			var lifecycleHandler = fetchLifeCycleHandler().getOrElseThrow((t)->t);
			if(lifecycleHandler.isDefined()){
				lifecycleHandler.get().callPluginLoadingHook(configuration).getOrElseThrow((t)->t);
			}
			return null;
		});
	}

	/**
	 * Will load all i18n resources into the configuration object from the plugin's i18n package folder
	 * Resources are defined as standard resource bundle properties files.
	 * The configuration will have the following type inside the I18N key: Map&lt;Locale, Map&lt;String,String&gt;&gt;
	 * @param configuration
	 * @return
	 */
	private Try<Void> loadI18NResources(Configuration.Builder configuration) {
		return Try.of(() -> {
			Reflections reflections = new Reflections(
			  normalizePackageNameForReflection(this.specification.getRootPackage().concat(".i18n")),
			  new ResourcesScanner());

			HashSet.ofAll(reflections.getResources(Pattern.compile(".*\\.properties")))
			  .map((name) -> name.replaceAll("\\.properties", ""))
			  .map(Plugin::bundleFromFileName)
			  .filter(Option::isDefined).map(Option::get)
			  .flatMap(Plugin::entriesFromBundle)
			  .forEach(bundleEntry -> updateConfigWithBundleEntry(configuration, bundleEntry));

			return null;
		});
	}

	/**
	 * Will load the map generators of this plugin into the configuration.
	 * @param configuration
	 * @return
	 */
	private Try<Void> loadMapGenerators(Configuration.Builder configuration) {
		return Try.of(()->{
			var mapGenerators = fetchMapGenerators().getOrElseThrow((t) -> t);
			var addOperation = configuration.addAllTo(CoreConfigKeyEnum.MAPS, mapGenerators);
			if(addOperation.isFailure()) {
				throw new PluginLoadingException(addOperation.getCause());
			}

			return null;
		});
	}

	/**
	 * Loads the terrain resources defined in this plugin, found in the CoreResourcesTypes.TERRAIN_TYPES.getFileName() file
	 * in the class folder of the plugin, into the configuration under the CoreConfigKeyEnum.TERRAIN_TYPES key.
	 *
	 * @param configuration
	 * @return
	 */
	private Try<Void> loadTerrainResources(Configuration.Builder configuration) {
		var terrainTypesFilename = toClasspathFile(CoreResourcesTypes.TERRAIN_TYPES.getFileName());
		return ConfigLoader.getConfigFor(terrainTypesFilename, TerrainsTypesMapping.class)
		  .map((mapping) -> mapping.getTypes().toArray(new String[]{}))
		  .map(API::Set)
		  // Merge with previous terrain config
		  .peek((terrainSet) -> {
			  var newTerrainSet = terrainSet;
			  var existentTerrainConfig = configuration.getConfig(TERRAIN_TYPES);
			  if (existentTerrainConfig.isDefined()) {
				  newTerrainSet = newTerrainSet.union((Set<String>) existentTerrainConfig.get());
			  }
			  configuration.putConfig(TERRAIN_TYPES, newTerrainSet);
		  })
		  .map((discardedResult) -> (Void) null)
		  // The terrain file is not mandatory for a plugin
		  .recover((e) -> Match(e).of(
			Case($(instanceOf(ConfigFileNotFoundException.class)), (Void) null)
		  ));
	}

	/**
	 * Retrieve the plugin lifecycle hooks if any have been defined.
	 * @return
	 */
	private Try<Option<PluginLifecycleHandlerWrapper>> fetchLifeCycleHandler() {
		return Try.of(()->{
			Reflections reflections = new Reflections(normalizePackageNameForReflection(this.specification.getRootPackage()));
			var lifecycleHandlersClasses = reflections.getTypesAnnotatedWith(PluginLifecycleHandler.class);
			if(lifecycleHandlersClasses.size() > 1) {
				throw new InvalidPluginLifecycleHandlerException(
				  format("Too many plugin lifecycle handlers for plugin %s",specification.getPluginName()));
			}

			Option<PluginLifecycleHandlerWrapper> pluginLifecycleHandler = Option.none();
			if(!lifecycleHandlersClasses.isEmpty()) {
				var pluginLifecycleHandlerTry = PluginLifecycleHandlerWrapper.from(lifecycleHandlersClasses.iterator().next());
				if (pluginLifecycleHandlerTry.isFailure()) {
					throw pluginLifecycleHandlerTry.getCause();
				}

				pluginLifecycleHandler = Option.of(pluginLifecycleHandlerTry.get());
			}

			return pluginLifecycleHandler;
		});
	}

	private Try<Option<Object>> fetchGameParameterProviders() {
		return Try.failure(new OperationNotSupportedException());
	}

	/**
	 * From the root package of the plugin, will try to fetch all map generators found inside that root package.
	 * An empty set is a valid value.
	 *
	 * May return the following error:
	 *  - {@link MapProviderWrappingException} if there was an error while wrapping a map provider or map generator
	 *  - unknown errors as of yet, to be discovered with testing
	 * @return
	 */
	private Try<Set<MapGeneratorWrapper>> fetchMapGenerators() {

		return Try.of(()->{
			Reflections reflections = new Reflections(normalizePackageNameForReflection(this.specification.getRootPackage()));
			var mapProviders = reflections.getTypesAnnotatedWith(MapProvider.class);

			Set<MapGeneratorWrapper> mapGeneratorWrappers = HashSet.empty();
			if(!mapProviders.isEmpty()) {
				var mapProvidersWrappingOperations = List.ofAll(mapProviders.stream()).map(MapProviderWrapper::from);
				if(Try.sequence(mapProvidersWrappingOperations).isFailure()) {
					var failures = mapProvidersWrappingOperations.filter(Try::isFailure).map(Try::getCause);
					throw new MapProviderWrappingException(failures);
				}

				var mapGenerators = mapProvidersWrappingOperations.map(Try::get)
				  .map(MapProviderWrapper::getMapGenerators)
				  .collect(HashSet.collector());

				if(Try.sequence(mapGenerators).isFailure()) {
					var failures = mapGenerators.filter(Try::isFailure).map(Try::getCause);
					throw new MapProviderWrappingException(failures);
				}

				mapGeneratorWrappers = mapGenerators.flatMap(Try::get);
			}

			return mapGeneratorWrappers;
		});
	}

	/**
	 * Given a filename to be fetched from the plugin classpath, transforms it to a fully
	 * pathed resource.
	 *
	 * @param fileName
	 * @return
	 */
	private String toClasspathFile(String fileName) {
		return packageToFolderPath(this.specification.getRootPackage()).concat("/" + fileName);
	}
}
